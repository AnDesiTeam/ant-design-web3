"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[1832],{61820:function(R,f,i){i.r(f);var t=i(96649),r=i(99661),l=i(11527),_=(0,r.Qz)({rpcs:[new r.ic({apiKey:"d0eeefc2a4da4a8ba707889259b437d6"})],wallets:[new r.AX({projectId:"c07c0051c2055890eade3556618e38a6"}),new r.Y8],chains:[r.p5.RJ]}),D=function(){return(0,l.jsx)(r.Gn,{provider:_,children:(0,l.jsx)(t.wR,{children:(0,l.jsx)(t.NL,{})})})};f.default=D},37669:function(R,f,i){i.r(f);var t=i(14433),r=i(51990),l=i(39848),_=i(8851),D=i(56845),M=i(22949),U=i(82748),E=i(96649),C=i(11527),p=(0,t.QB)([r.R],[(0,_.I)()]),v=p.publicClient,e=p.chains,n=(0,l._g)({autoConnect:!0,publicClient:v,connectors:[new D.i,new M.z({chains:e,options:{showQrModal:!1,projectId:"c07c0051c2055890eade3556618e38a6"}})]}),d=function(){return(0,C.jsx)(U.h,{config:n,children:(0,C.jsx)(E.wR,{children:(0,C.jsx)(E.NL,{})})})};f.default=d},94313:function(R,f,i){i.r(f);var t=i(14433),r=i(51990),l=i(39848),_=i(8851),D=i(56845),M=i(22949),U=i(82748),E=i(96649),C=i(11527),p=(0,t.QB)([r.R],[(0,_.I)()]),v=p.publicClient,e=p.chains,n=(0,l._g)({autoConnect:!0,publicClient:v,connectors:[new D.i,new M.z({chains:e,options:{projectId:"c07c0051c2055890eade3556618e38a6"}})]}),d=function(){return(0,C.jsx)(U.h,{config:n,children:(0,C.jsx)(E.wR,{children:(0,C.jsx)(E.NL,{})})})};f.default=d},56845:function(R,f,i){i.d(f,{i:function(){return U}});var t=i(11163),r=i(80713),l=i(31043),_=i(296),D=i(56907),M,U=class extends t._{constructor({chains:E,options:C}={}){const p={name:"MetaMask",shimDisconnect:!0,getProvider(){function v(n){if(n!=null&&n.isMetaMask&&!(n.isBraveWallet&&!n._events&&!n._state)&&!n.isApexWallet&&!n.isAvalanche&&!n.isBitKeep&&!n.isBlockWallet&&!n.isCoin98&&!n.isFordefi&&!n.isMathWallet&&!(n.isOkxWallet||n.isOKExWallet)&&!(n.isOneInchIOSWallet||n.isOneInchAndroidWallet)&&!n.isOpera&&!n.isPortal&&!n.isRabby&&!n.isDefiant&&!n.isTokenPocket&&!n.isTokenary&&!n.isZeal&&!n.isZerion)return n}if(typeof window>"u")return;const e=window.ethereum;return e!=null&&e.providers?e.providers.find(v):v(e)},...C};super({chains:E,options:p}),this.id="metaMask",this.shimDisconnectKey=`${this.id}.shimDisconnect`,(0,l.Ko)(this,M,void 0),(0,l.qx)(this,M,p.UNSTABLE_shimOnConnectSelectAccount)}async connect({chainId:E}={}){var C,p,v,e;try{const n=await this.getProvider();if(!n)throw new r.N;n.on&&(n.on("accountsChanged",this.onAccountsChanged),n.on("chainChanged",this.onChainChanged),n.on("disconnect",this.onDisconnect)),this.emit("message",{type:"connecting"});let d=null;if((0,l.ac)(this,M)&&((C=this.options)!=null&&C.shimDisconnect)&&!((p=this.storage)!=null&&p.getItem(this.shimDisconnectKey))&&(d=await this.getAccount().catch(()=>null),!!d))try{await n.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}),d=await this.getAccount()}catch(P){if(this.isUserRejectedRequestError(P))throw new _.ab(P);if(P.code===new _.pT(P).code)throw P}if(!d){const K=await n.request({method:"eth_requestAccounts"});d=(0,D.K)(K[0])}let g=await this.getChainId(),I=this.isChainUnsupported(g);return E&&g!==E&&(g=(await this.switchChain(E)).id,I=this.isChainUnsupported(g)),(v=this.options)!=null&&v.shimDisconnect&&((e=this.storage)==null||e.setItem(this.shimDisconnectKey,!0)),{account:d,chain:{id:g,unsupported:I},provider:n}}catch(n){throw this.isUserRejectedRequestError(n)?new _.ab(n):n.code===-32002?new _.pT(n):n}}};M=new WeakMap},22949:function(R,f,i){i.d(f,{z:function(){return V}});var t=i(31043),r=i(3332),l=i(56907),_=i(296),D=i(9474),M=i(86427),U=i(30460),E="eip155",C="store",p="requestedChains",v="wallet_addEthereumChain",e,n,d,g,I,K,P,z,H,G,y,k,W,T,B,Q,N,b,S,Y,V=class extends t.wR{constructor(s){super({...s,options:{isNewChainsStale:!0,...s.options}}),(0,t.Ko)(this,d),(0,t.Ko)(this,I),(0,t.Ko)(this,P),(0,t.Ko)(this,H),(0,t.Ko)(this,y),(0,t.Ko)(this,W),(0,t.Ko)(this,B),(0,t.Ko)(this,N),(0,t.Ko)(this,S),this.id="walletConnect",this.name="WalletConnect",this.ready=!0,(0,t.Ko)(this,e,void 0),(0,t.Ko)(this,n,void 0),this.onAccountsChanged=a=>{a.length===0?this.emit("disconnect"):this.emit("change",{account:(0,l.K)(a[0])})},this.onChainChanged=a=>{const h=Number(a),c=this.isChainUnsupported(h);this.emit("change",{chain:{id:h,unsupported:c}})},this.onDisconnect=()=>{(0,t.U9)(this,W,T).call(this,[]),this.emit("disconnect")},this.onDisplayUri=a=>{this.emit("message",{type:"display_uri",data:a})},this.onConnect=()=>{this.emit("connect",{})},(0,t.U9)(this,d,g).call(this)}async connect({chainId:s,pairingTopic:a}={}){var h,c,o,m,A;try{let u=s;if(!u){const L=(h=this.storage)==null?void 0:h.getItem(C),O=(m=(o=(c=L==null?void 0:L.state)==null?void 0:c.data)==null?void 0:o.chain)==null?void 0:m.id;O&&!this.isChainUnsupported(O)?u=O:u=(A=this.chains[0])==null?void 0:A.id}if(!u)throw new Error("No chains found on connector.");const w=await this.getProvider();(0,t.U9)(this,H,G).call(this);const j=(0,t.U9)(this,P,z).call(this);if(w.session&&j&&await w.disconnect(),!w.session||j){const L=this.chains.filter(O=>O.id!==u).map(O=>O.id);this.emit("message",{type:"connecting"}),await w.connect({pairingTopic:a,chains:[u],optionalChains:L.length?L:void 0}),(0,t.U9)(this,W,T).call(this,this.chains.map(({id:O})=>O))}const x=await w.enable(),Z=(0,l.K)(x[0]),F=await this.getChainId(),J=this.isChainUnsupported(F);return{account:Z,chain:{id:F,unsupported:J}}}catch(u){throw/user rejected/i.test(u==null?void 0:u.message)?new _.ab(u):u}}async disconnect(){const s=await this.getProvider();try{await s.disconnect()}catch(a){if(!/No matching key/i.test(a.message))throw a}finally{(0,t.U9)(this,y,k).call(this),(0,t.U9)(this,W,T).call(this,[])}}async getAccount(){const{accounts:s}=await this.getProvider();return(0,l.K)(s[0])}async getChainId(){const{chainId:s}=await this.getProvider();return s}async getProvider({chainId:s}={}){return(0,t.ac)(this,e)||await(0,t.U9)(this,d,g).call(this),s&&await this.switchChain(s),(0,t.ac)(this,e)}async getWalletClient({chainId:s}={}){const[a,h]=await Promise.all([this.getProvider({chainId:s}),this.getAccount()]),c=this.chains.find(o=>o.id===s);if(!a)throw new Error("provider is required.");return(0,D.K)({account:h,chain:c,transport:(0,M.P)(a)})}async isAuthorized(){try{const[s,a]=await Promise.all([this.getAccount(),this.getProvider()]),h=(0,t.U9)(this,P,z).call(this);if(!s)return!1;if(h&&a.session){try{await a.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(s){var h,c;const a=this.chains.find(o=>o.id===s);if(!a)throw new _.x3(new Error("chain not found on connector."));try{const o=await this.getProvider(),m=(0,t.U9)(this,N,b).call(this),A=(0,t.U9)(this,S,Y).call(this);if(!m.includes(s)&&A.includes(v)){await o.request({method:v,params:[{chainId:(0,U.eC)(a.id),blockExplorerUrls:[(c=(h=a.blockExplorers)==null?void 0:h.default)==null?void 0:c.url],chainName:a.name,nativeCurrency:a.nativeCurrency,rpcUrls:[...a.rpcUrls.default.http]}]});const w=(0,t.U9)(this,B,Q).call(this);w.push(s),(0,t.U9)(this,W,T).call(this,w)}return await o.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,U.eC)(s)}]}),a}catch(o){const m=typeof o=="string"?o:o==null?void 0:o.message;throw/user rejected request/i.test(m)?new _.ab(o):new _.x3(o)}}};e=new WeakMap,n=new WeakMap,d=new WeakSet,g=async function(){return!(0,t.ac)(this,n)&&typeof window<"u"&&(0,t.qx)(this,n,(0,t.U9)(this,I,K).call(this)),(0,t.ac)(this,n)},I=new WeakSet,K=async function(){const{EthereumProvider:s,OPTIONAL_EVENTS:a,OPTIONAL_METHODS:h}=await i.e(5217).then(i.bind(i,85217)),[c,...o]=this.chains.map(({id:m})=>m);if(c){const{projectId:m,showQrModal:A=!0,qrModalOptions:u,metadata:w,relayUrl:j}=this.options;(0,t.qx)(this,e,await s.init({showQrModal:A,qrModalOptions:u,projectId:m,optionalMethods:h,optionalEvents:a,chains:[c],optionalChains:o.length?o:void 0,rpcMap:Object.fromEntries(this.chains.map(x=>[x.id,x.rpcUrls.default.http[0]])),metadata:w,relayUrl:j}))}},P=new WeakSet,z=function(){if((0,t.U9)(this,S,Y).call(this).includes(v)||!this.options.isNewChainsStale)return!1;const a=(0,t.U9)(this,B,Q).call(this),h=this.chains.map(({id:o})=>o),c=(0,t.U9)(this,N,b).call(this);return c.length&&!c.some(o=>h.includes(o))?!1:!h.every(o=>a.includes(o))},H=new WeakSet,G=function(){(0,t.ac)(this,e)&&((0,t.U9)(this,y,k).call(this),(0,t.ac)(this,e).on("accountsChanged",this.onAccountsChanged),(0,t.ac)(this,e).on("chainChanged",this.onChainChanged),(0,t.ac)(this,e).on("disconnect",this.onDisconnect),(0,t.ac)(this,e).on("session_delete",this.onDisconnect),(0,t.ac)(this,e).on("display_uri",this.onDisplayUri),(0,t.ac)(this,e).on("connect",this.onConnect))},y=new WeakSet,k=function(){(0,t.ac)(this,e)&&((0,t.ac)(this,e).removeListener("accountsChanged",this.onAccountsChanged),(0,t.ac)(this,e).removeListener("chainChanged",this.onChainChanged),(0,t.ac)(this,e).removeListener("disconnect",this.onDisconnect),(0,t.ac)(this,e).removeListener("session_delete",this.onDisconnect),(0,t.ac)(this,e).removeListener("display_uri",this.onDisplayUri),(0,t.ac)(this,e).removeListener("connect",this.onConnect))},W=new WeakSet,T=function(s){var a;(a=this.storage)==null||a.setItem(p,s)},B=new WeakSet,Q=function(){var s;return((s=this.storage)==null?void 0:s.getItem(p))??[]},N=new WeakSet,b=function(){var c,o,m;if(!(0,t.ac)(this,e))return[];const s=(c=(0,t.ac)(this,e).session)==null?void 0:c.namespaces;return s?((m=(o=(0,r.fK)(s)[E])==null?void 0:o.chains)==null?void 0:m.map(A=>parseInt(A.split(":")[1]||"")))??[]:[]},S=new WeakSet,Y=function(){var c,o;if(!(0,t.ac)(this,e))return[];const s=(c=(0,t.ac)(this,e).session)==null?void 0:c.namespaces;return s?((o=(0,r.fK)(s)[E])==null?void 0:o.methods)??[]:[]}},8851:function(R,f,i){i.d(f,{I:function(){return t}});function t(){return function(r){return r.rpcUrls.public.http[0]?{chain:r,rpcUrls:r.rpcUrls.public}:null}}}}]);
