"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[5242],{46898:function(Wt,vt,ut){ut.d(vt,{FF:function(){return bt},S5:function(){return it},Wd:function(){return wt},bytesToNumberBE:function(){return tt},ci:function(){return O},dQ:function(){return Lt},eV:function(){return Q},hexToBytes:function(){return L},n$:function(){return D},ql:function(){return et},tL:function(){return C},ty:function(){return X}});const rt=BigInt(0),w=BigInt(1),j=BigInt(2),N=c=>c instanceof Uint8Array,ot=Array.from({length:256},(c,A)=>A.toString(16).padStart(2,"0"));function O(c){if(!N(c))throw new Error("Uint8Array expected");let A="";for(let M=0;M<c.length;M++)A+=ot[c[M]];return A}function G(c){const A=c.toString(16);return A.length&1?`0${A}`:A}function Y(c){if(typeof c!="string")throw new Error("hex string expected, got "+typeof c);return BigInt(c===""?"0":`0x${c}`)}function L(c){if(typeof c!="string")throw new Error("hex string expected, got "+typeof c);const A=c.length;if(A%2)throw new Error("padded hex string expected, got unpadded hex of length "+A);const M=new Uint8Array(A/2);for(let K=0;K<M.length;K++){const lt=K*2,ct=c.slice(lt,lt+2),xt=Number.parseInt(ct,16);if(Number.isNaN(xt)||xt<0)throw new Error("Invalid byte sequence");M[K]=xt}return M}function tt(c){return Y(O(c))}function X(c){if(!N(c))throw new Error("Uint8Array expected");return Y(O(Uint8Array.from(c).reverse()))}function C(c,A){return L(c.toString(16).padStart(A*2,"0"))}function it(c,A){return C(c,A).reverse()}function P(c){return L(G(c))}function et(c,A,M){let K;if(typeof A=="string")try{K=L(A)}catch(ct){throw new Error(`${c} must be valid hex string, got "${A}". Cause: ${ct}`)}else if(N(A))K=Uint8Array.from(A);else throw new Error(`${c} must be hex string or Uint8Array`);const lt=K.length;if(typeof M=="number"&&lt!==M)throw new Error(`${c} expected ${M} bytes, got ${lt}`);return K}function Q(...c){const A=new Uint8Array(c.reduce((K,lt)=>K+lt.length,0));let M=0;return c.forEach(K=>{if(!N(K))throw new Error("Uint8Array expected");A.set(K,M),M+=K.length}),A}function wt(c,A){if(c.length!==A.length)return!1;for(let M=0;M<c.length;M++)if(c[M]!==A[M])return!1;return!0}function pt(c){if(typeof c!="string")throw new Error(`utf8ToBytes expected string, got ${typeof c}`);return new Uint8Array(new TextEncoder().encode(c))}function gt(c){let A;for(A=0;c>rt;c>>=w,A+=1);return A}function mt(c,A){return c>>BigInt(A)&w}const Nt=(c,A,M)=>c|(M?w:rt)<<BigInt(A),Lt=c=>(j<<BigInt(c-1))-w,g=c=>new Uint8Array(c),T=c=>Uint8Array.from(c);function D(c,A,M){if(typeof c!="number"||c<2)throw new Error("hashLen must be a number");if(typeof A!="number"||A<2)throw new Error("qByteLen must be a number");if(typeof M!="function")throw new Error("hmacFn must be a function");let K=g(c),lt=g(c),ct=0;const xt=()=>{K.fill(1),lt.fill(0),ct=0},_t=(...Bt)=>M(lt,K,...Bt),kt=(Bt=g())=>{lt=_t(T([0]),Bt),K=_t(),Bt.length!==0&&(lt=_t(T([1]),Bt),K=_t())},te=()=>{if(ct++>=1e3)throw new Error("drbg: tried 1000 values");let Bt=0;const Ht=[];for(;Bt<A;){K=_t();const Rt=K.slice();Ht.push(Rt),Bt+=K.length}return Q(...Ht)};return(Bt,Ht)=>{xt(),kt(Bt);let Rt;for(;!(Rt=Ht(te()));)kt();return xt(),Rt}}const W={bigint:c=>typeof c=="bigint",function:c=>typeof c=="function",boolean:c=>typeof c=="boolean",string:c=>typeof c=="string",stringOrUint8Array:c=>typeof c=="string"||c instanceof Uint8Array,isSafeInteger:c=>Number.isSafeInteger(c),array:c=>Array.isArray(c),field:(c,A)=>A.Fp.isValid(c),hash:c=>typeof c=="function"&&Number.isSafeInteger(c.outputLen)};function bt(c,A,M={}){const K=(lt,ct,xt)=>{const _t=W[ct];if(typeof _t!="function")throw new Error(`Invalid validator "${ct}", expected function`);const kt=c[lt];if(!(xt&&kt===void 0)&&!_t(kt,c))throw new Error(`Invalid param ${String(lt)}=${kt} (${typeof kt}), expected ${ct}`)};for(const[lt,ct]of Object.entries(A))K(lt,ct,!1);for(const[lt,ct]of Object.entries(M))K(lt,ct,!0);return c}},6254:function(Wt,vt,ut){ut.d(vt,{secp256k1:function(){return Pt}});var rt=ut(23501),w=ut(46898);const j=BigInt(0),N=BigInt(1),ot=BigInt(2),O=BigInt(3),G=BigInt(4),Y=BigInt(5),L=BigInt(8),tt=BigInt(9),X=BigInt(16);function C(e,n){const t=e%n;return t>=j?t:n+t}function it(e,n,t){if(t<=j||n<j)throw new Error("Expected power/modulo > 0");if(t===N)return j;let r=N;for(;n>j;)n&N&&(r=r*e%t),e=e*e%t,n>>=N;return r}function P(e,n,t){let r=e;for(;n-- >j;)r*=r,r%=t;return r}function et(e,n){if(e===j||n<=j)throw new Error(`invert: expected positive integers, got n=${e} mod=${n}`);let t=C(e,n),r=n,f=j,i=N,b=N,a=j;for(;t!==j;){const u=r/t,x=r%t,E=f-b*u,z=i-a*u;r=t,t=x,f=b,i=a,b=E,a=z}if(r!==N)throw new Error("invert: does not exist");return C(f,n)}function Q(e){const n=(e-N)/ot;let t,r,f;for(t=e-N,r=0;t%ot===j;t/=ot,r++);for(f=ot;f<e&&it(f,n,e)!==e-N;f++);if(r===1){const b=(e+N)/G;return function(s,u){const x=s.pow(u,b);if(!s.eql(s.sqr(x),u))throw new Error("Cannot find square root");return x}}const i=(t+N)/ot;return function(a,s){if(a.pow(s,n)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=r,x=a.pow(a.mul(a.ONE,f),t),E=a.pow(s,i),z=a.pow(s,t);for(;!a.eql(z,a.ONE);){if(a.eql(z,a.ZERO))return a.ZERO;let J=1;for(let l=a.sqr(z);J<u&&!a.eql(l,a.ONE);J++)l=a.sqr(l);const I=a.pow(x,N<<BigInt(u-J-1));x=a.sqr(I),E=a.mul(E,I),z=a.mul(z,x),u=J}return E}}function wt(e){if(e%G===O){const n=(e+N)/G;return function(r,f){const i=r.pow(f,n);if(!r.eql(r.sqr(i),f))throw new Error("Cannot find square root");return i}}if(e%L===Y){const n=(e-Y)/L;return function(r,f){const i=r.mul(f,ot),b=r.pow(i,n),a=r.mul(f,b),s=r.mul(r.mul(a,ot),b),u=r.mul(a,r.sub(s,r.ONE));if(!r.eql(r.sqr(u),f))throw new Error("Cannot find square root");return u}}return e%X,Q(e)}const pt=(e,n)=>(C(e,n)&N)===N,gt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function mt(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=gt.reduce((r,f)=>(r[f]="function",r),n);return(0,w.FF)(e,t)}function Nt(e,n,t){if(t<j)throw new Error("Expected power > 0");if(t===j)return e.ONE;if(t===N)return n;let r=e.ONE,f=n;for(;t>j;)t&N&&(r=e.mul(r,f)),f=e.sqr(f),t>>=N;return r}function Lt(e,n){const t=new Array(n.length),r=n.reduce((i,b,a)=>e.is0(b)?i:(t[a]=i,e.mul(i,b)),e.ONE),f=e.inv(r);return n.reduceRight((i,b,a)=>e.is0(b)?i:(t[a]=e.mul(i,t[a]),e.mul(i,b)),f),t}function g(e,n,t){return e.mul(n,typeof t=="bigint"?et(t,e.ORDER):e.inv(t))}function T(e){const n=(e.ORDER-N)/ot;return t=>{const r=e.pow(t,n);return e.eql(r,e.ZERO)||e.eql(r,e.ONE)}}function D(e,n){const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function W(e,n,t=!1,r={}){if(e<=j)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:f,nByteLength:i}=D(e,n);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const b=wt(e),a=Object.freeze({ORDER:e,BITS:f,BYTES:i,MASK:(0,w.dQ)(f),ZERO:j,ONE:N,create:s=>C(s,e),isValid:s=>{if(typeof s!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof s}`);return j<=s&&s<e},is0:s=>s===j,isOdd:s=>(s&N)===N,neg:s=>C(-s,e),eql:(s,u)=>s===u,sqr:s=>C(s*s,e),add:(s,u)=>C(s+u,e),sub:(s,u)=>C(s-u,e),mul:(s,u)=>C(s*u,e),pow:(s,u)=>Nt(a,s,u),div:(s,u)=>C(s*et(u,e),e),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>et(s,e),sqrt:r.sqrt||(s=>b(a,s)),invertBatch:s=>Lt(a,s),cmov:(s,u,x)=>x?u:s,toBytes:s=>t?(0,w.S5)(s,i):(0,w.tL)(s,i),fromBytes:s=>{if(s.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${s.length}`);return t?(0,w.ty)(s):(0,w.bytesToNumberBE)(s)}});return Object.freeze(a)}function bt(e,n){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const t=e.sqrt(n);return e.isOdd(t)?t:e.neg(t)}function c(e,n){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const t=e.sqrt(n);return e.isOdd(t)?e.neg(t):t}function A(e,n,t=!1){e=ensureBytes("privateHash",e);const r=e.length,f=D(n).nByteLength+8;if(f<24||r<f||r>1024)throw new Error(`hashToPrivateScalar: expected ${f}-1024 bytes of input, got ${r}`);const i=t?bytesToNumberLE(e):bytesToNumberBE(e);return C(i,n-N)+N}function M(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function K(e){const n=M(e);return n+Math.ceil(n/2)}function lt(e,n,t=!1){const r=e.length,f=M(n),i=K(n);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const b=t?(0,w.bytesToNumberBE)(e):(0,w.ty)(e),a=C(b,n-N)+N;return t?(0,w.S5)(a,f):(0,w.tL)(a,f)}var ct=ut(60149),xt=ut(82403);class _t extends xt.kb{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,(0,ct.vp)(n);const r=(0,xt.O0)(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const f=this.blockLen,i=new Uint8Array(f);i.set(r.length>f?n.create().update(r).digest():r);for(let b=0;b<i.length;b++)i[b]^=54;this.iHash.update(i),this.oHash=n.create();for(let b=0;b<i.length;b++)i[b]^=106;this.oHash.update(i),i.fill(0)}update(n){return(0,ct.Gg)(this),this.iHash.update(n),this}digestInto(n){(0,ct.Gg)(this),(0,ct.aI)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:f,destroyed:i,blockLen:b,outputLen:a}=this;return n=n,n.finished=f,n.destroyed=i,n.blockLen=b,n.outputLen=a,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const kt=(e,n,t)=>new _t(e,n).update(t).digest();kt.create=(e,n)=>new _t(e,n);const te=BigInt(0),zt=BigInt(1);function Bt(e,n){const t=(f,i)=>{const b=i.negate();return f?b:i},r=f=>{const i=Math.ceil(n/f)+1,b=2**(f-1);return{windows:i,windowSize:b}};return{constTimeNegate:t,unsafeLadder(f,i){let b=e.ZERO,a=f;for(;i>te;)i&zt&&(b=b.add(a)),a=a.double(),i>>=zt;return b},precomputeWindow(f,i){const{windows:b,windowSize:a}=r(i),s=[];let u=f,x=u;for(let E=0;E<b;E++){x=u,s.push(x);for(let z=1;z<a;z++)x=x.add(u),s.push(x);u=x.double()}return s},wNAF(f,i,b){const{windows:a,windowSize:s}=r(f);let u=e.ZERO,x=e.BASE;const E=BigInt(2**f-1),z=2**f,J=BigInt(f);for(let I=0;I<a;I++){const l=I*s;let y=Number(b&E);b>>=J,y>s&&(y-=z,b+=zt);const p=l,B=l+Math.abs(y)-1,_=I%2!==0,H=y<0;y===0?x=x.add(t(_,i[p])):u=u.add(t(H,i[B]))}return{p:u,f:x}},wNAFCached(f,i,b,a){const s=f._WINDOW_SIZE||1;let u=i.get(f);return u||(u=this.precomputeWindow(f,s),s!==1&&i.set(f,a(u))),this.wNAF(s,u,b)}}}function Ht(e){return mt(e.Fp),(0,w.FF)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...D(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Rt(e){const n=Ht(e);w.FF(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:f}=n;if(t){if(!r.eql(f,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:se,hexToBytes:Yt}=w,Ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(e){const{Err:n}=Ct;if(e.length<2||e[0]!==2)throw new n("Invalid signature integer tag");const t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:se(r),l:e.subarray(t+2)}},toSig(e){const{Err:n}=Ct,t=typeof e=="string"?Yt(e):e;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new n("Invalid signature tag");if(t[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:f,l:i}=Ct._parseInt(t.subarray(2)),{d:b,l:a}=Ct._parseInt(i);if(a.length)throw new n("Invalid signature: left bytes after parsing");return{r:f,s:b}},hexFromSig(e){const n=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const x=u.toString(16);return x.length&1?`0${x}`:x},r=n(t(e.s)),f=n(t(e.r)),i=r.length/2,b=f.length/2,a=t(i),s=t(b);return`30${t(b+i+4)}02${s}${f}02${a}${r}`}},Tt=BigInt(0),dt=BigInt(1),Vt=BigInt(2),ee=BigInt(3),ie=BigInt(4);function ce(e){const n=Rt(e),{Fp:t}=n,r=n.toBytes||((I,l,y)=>{const p=l.toAffine();return w.eV(Uint8Array.from([4]),t.toBytes(p.x),t.toBytes(p.y))}),f=n.fromBytes||(I=>{const l=I.subarray(1),y=t.fromBytes(l.subarray(0,t.BYTES)),p=t.fromBytes(l.subarray(t.BYTES,2*t.BYTES));return{x:y,y:p}});function i(I){const{a:l,b:y}=n,p=t.sqr(I),B=t.mul(p,I);return t.add(t.add(B,t.mul(I,l)),y)}if(!t.eql(t.sqr(n.Gy),i(n.Gx)))throw new Error("bad generator point: equation left != right");function b(I){return typeof I=="bigint"&&Tt<I&&I<n.n}function a(I){if(!b(I))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function s(I){const{allowedPrivateKeyLengths:l,nByteLength:y,wrapPrivateKey:p,n:B}=n;if(l&&typeof I!="bigint"){if(I instanceof Uint8Array&&(I=w.ci(I)),typeof I!="string"||!l.includes(I.length))throw new Error("Invalid key");I=I.padStart(y*2,"0")}let _;try{_=typeof I=="bigint"?I:w.bytesToNumberBE((0,w.ql)("private key",I,y))}catch{throw new Error(`private key must be ${y} bytes, hex or bigint, not ${typeof I}`)}return p&&(_=C(_,B)),a(_),_}const u=new Map;function x(I){if(!(I instanceof E))throw new Error("ProjectivePoint expected")}class E{constructor(l,y,p){if(this.px=l,this.py=y,this.pz=p,l==null||!t.isValid(l))throw new Error("x required");if(y==null||!t.isValid(y))throw new Error("y required");if(p==null||!t.isValid(p))throw new Error("z required")}static fromAffine(l){const{x:y,y:p}=l||{};if(!l||!t.isValid(y)||!t.isValid(p))throw new Error("invalid affine point");if(l instanceof E)throw new Error("projective point not allowed");const B=_=>t.eql(_,t.ZERO);return B(y)&&B(p)?E.ZERO:new E(y,p,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const y=t.invertBatch(l.map(p=>p.pz));return l.map((p,B)=>p.toAffine(y[B])).map(E.fromAffine)}static fromHex(l){const y=E.fromAffine(f((0,w.ql)("pointHex",l)));return y.assertValidity(),y}static fromPrivateKey(l){return E.BASE.multiply(s(l))}_setWindowSize(l){this._WINDOW_SIZE=l,u.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y}=this.toAffine();if(!t.isValid(l)||!t.isValid(y))throw new Error("bad point: x or y not FE");const p=t.sqr(y),B=i(l);if(!t.eql(p,B))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(t.isOdd)return!t.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){x(l);const{px:y,py:p,pz:B}=this,{px:_,py:H,pz:V}=l,S=t.eql(t.mul(y,V),t.mul(_,B)),k=t.eql(t.mul(p,V),t.mul(H,B));return S&&k}negate(){return new E(this.px,t.neg(this.py),this.pz)}double(){const{a:l,b:y}=n,p=t.mul(y,ee),{px:B,py:_,pz:H}=this;let V=t.ZERO,S=t.ZERO,k=t.ZERO,R=t.mul(B,B),Et=t.mul(_,_),at=t.mul(H,H),F=t.mul(B,_);return F=t.add(F,F),k=t.mul(B,H),k=t.add(k,k),V=t.mul(l,k),S=t.mul(p,at),S=t.add(V,S),V=t.sub(Et,S),S=t.add(Et,S),S=t.mul(V,S),V=t.mul(F,V),k=t.mul(p,k),at=t.mul(l,at),F=t.sub(R,at),F=t.mul(l,F),F=t.add(F,k),k=t.add(R,R),R=t.add(k,R),R=t.add(R,at),R=t.mul(R,F),S=t.add(S,R),at=t.mul(_,H),at=t.add(at,at),R=t.mul(at,F),V=t.sub(V,R),k=t.mul(at,Et),k=t.add(k,k),k=t.add(k,k),new E(V,S,k)}add(l){x(l);const{px:y,py:p,pz:B}=this,{px:_,py:H,pz:V}=l;let S=t.ZERO,k=t.ZERO,R=t.ZERO;const Et=n.a,at=t.mul(n.b,ee);let F=t.mul(y,_),St=t.mul(p,H),It=t.mul(B,V),Dt=t.add(y,p),m=t.add(_,H);Dt=t.mul(Dt,m),m=t.add(F,St),Dt=t.sub(Dt,m),m=t.add(y,B);let v=t.add(_,V);return m=t.mul(m,v),v=t.add(F,It),m=t.sub(m,v),v=t.add(p,B),S=t.add(H,V),v=t.mul(v,S),S=t.add(St,It),v=t.sub(v,S),R=t.mul(Et,m),S=t.mul(at,It),R=t.add(S,R),S=t.sub(St,R),R=t.add(St,R),k=t.mul(S,R),St=t.add(F,F),St=t.add(St,F),It=t.mul(Et,It),m=t.mul(at,m),St=t.add(St,It),It=t.sub(F,It),It=t.mul(Et,It),m=t.add(m,It),F=t.mul(St,m),k=t.add(k,F),F=t.mul(v,m),S=t.mul(Dt,S),S=t.sub(S,F),F=t.mul(Dt,St),R=t.mul(v,R),R=t.add(R,F),new E(S,k,R)}subtract(l){return this.add(l.negate())}is0(){return this.equals(E.ZERO)}wNAF(l){return J.wNAFCached(this,u,l,y=>{const p=t.invertBatch(y.map(B=>B.pz));return y.map((B,_)=>B.toAffine(p[_])).map(E.fromAffine)})}multiplyUnsafe(l){const y=E.ZERO;if(l===Tt)return y;if(a(l),l===dt)return this;const{endo:p}=n;if(!p)return J.unsafeLadder(this,l);let{k1neg:B,k1:_,k2neg:H,k2:V}=p.splitScalar(l),S=y,k=y,R=this;for(;_>Tt||V>Tt;)_&dt&&(S=S.add(R)),V&dt&&(k=k.add(R)),R=R.double(),_>>=dt,V>>=dt;return B&&(S=S.negate()),H&&(k=k.negate()),k=new E(t.mul(k.px,p.beta),k.py,k.pz),S.add(k)}multiply(l){a(l);let y=l,p,B;const{endo:_}=n;if(_){const{k1neg:H,k1:V,k2neg:S,k2:k}=_.splitScalar(y);let{p:R,f:Et}=this.wNAF(V),{p:at,f:F}=this.wNAF(k);R=J.constTimeNegate(H,R),at=J.constTimeNegate(S,at),at=new E(t.mul(at.px,_.beta),at.py,at.pz),p=R.add(at),B=Et.add(F)}else{const{p:H,f:V}=this.wNAF(y);p=H,B=V}return E.normalizeZ([p,B])[0]}multiplyAndAddUnsafe(l,y,p){const B=E.BASE,_=(V,S)=>S===Tt||S===dt||!V.equals(B)?V.multiplyUnsafe(S):V.multiply(S),H=_(this,y).add(_(l,p));return H.is0()?void 0:H}toAffine(l){const{px:y,py:p,pz:B}=this,_=this.is0();l==null&&(l=_?t.ONE:t.inv(B));const H=t.mul(y,l),V=t.mul(p,l),S=t.mul(B,l);if(_)return{x:t.ZERO,y:t.ZERO};if(!t.eql(S,t.ONE))throw new Error("invZ was invalid");return{x:H,y:V}}isTorsionFree(){const{h:l,isTorsionFree:y}=n;if(l===dt)return!0;if(y)return y(E,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:y}=n;return l===dt?this:y?y(E,this):this.multiplyUnsafe(n.h)}toRawBytes(l=!0){return this.assertValidity(),r(E,this,l)}toHex(l=!0){return w.ci(this.toRawBytes(l))}}E.BASE=new E(n.Gx,n.Gy,t.ONE),E.ZERO=new E(t.ZERO,t.ONE,t.ZERO);const z=n.nBitLength,J=Bt(E,n.endo?Math.ceil(z/2):z);return{CURVE:n,ProjectivePoint:E,normPrivateKeyToScalar:s,weierstrassEquation:i,isWithinCurveOrder:b}}function ge(e){const n=Ht(e);return w.FF(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function be(e){const n=ge(e),{Fp:t,n:r}=n,f=t.BYTES+1,i=2*t.BYTES+1;function b(m){return Tt<m&&m<t.ORDER}function a(m){return C(m,r)}function s(m){return et(m,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:x,weierstrassEquation:E,isWithinCurveOrder:z}=ce({...n,toBytes(m,v,Z){const ft=v.toAffine(),nt=t.toBytes(ft.x),yt=w.eV;return Z?yt(Uint8Array.from([v.hasEvenY()?2:3]),nt):yt(Uint8Array.from([4]),nt,t.toBytes(ft.y))},fromBytes(m){const v=m.length,Z=m[0],ft=m.subarray(1);if(v===f&&(Z===2||Z===3)){const nt=w.bytesToNumberBE(ft);if(!b(nt))throw new Error("Point is not on curve");const yt=E(nt);let At=t.sqrt(yt);const Ot=(At&dt)===dt;return(Z&1)===1!==Ot&&(At=t.neg(At)),{x:nt,y:At}}else if(v===i&&Z===4){const nt=t.fromBytes(ft.subarray(0,t.BYTES)),yt=t.fromBytes(ft.subarray(t.BYTES,2*t.BYTES));return{x:nt,y:yt}}else throw new Error(`Point of length ${v} was invalid. Expected ${f} compressed bytes or ${i} uncompressed bytes`)}}),J=m=>w.ci(w.tL(m,n.nByteLength));function I(m){const v=r>>dt;return m>v}function l(m){return I(m)?a(-m):m}const y=(m,v,Z)=>w.bytesToNumberBE(m.slice(v,Z));class p{constructor(v,Z,ft){this.r=v,this.s=Z,this.recovery=ft,this.assertValidity()}static fromCompact(v){const Z=n.nByteLength;return v=(0,w.ql)("compactSignature",v,Z*2),new p(y(v,0,Z),y(v,Z,2*Z))}static fromDER(v){const{r:Z,s:ft}=Ct.toSig((0,w.ql)("DER",v));return new p(Z,ft)}assertValidity(){if(!z(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!z(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(v){return new p(this.r,this.s,v)}recoverPublicKey(v){const{r:Z,s:ft,recovery:nt}=this,yt=k((0,w.ql)("msgHash",v));if(nt==null||![0,1,2,3].includes(nt))throw new Error("recovery id invalid");const At=nt===2||nt===3?Z+n.n:Z;if(At>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const Ot=nt&1?"03":"02",jt=u.fromHex(Ot+J(At)),Gt=s(At),Xt=a(-yt*Gt),re=a(ft*Gt),Mt=u.BASE.multiplyAndAddUnsafe(jt,Xt,re);if(!Mt)throw new Error("point at infinify");return Mt.assertValidity(),Mt}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return w.hexToBytes(this.toDERHex())}toDERHex(){return Ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return w.hexToBytes(this.toCompactHex())}toCompactHex(){return J(this.r)+J(this.s)}}const B={isValidPrivateKey(m){try{return x(m),!0}catch{return!1}},normPrivateKeyToScalar:x,randomPrivateKey:()=>{const m=K(n.n);return lt(n.randomBytes(m),n.n)},precompute(m=8,v=u.BASE){return v._setWindowSize(m),v.multiply(BigInt(3)),v}};function _(m,v=!0){return u.fromPrivateKey(m).toRawBytes(v)}function H(m){const v=m instanceof Uint8Array,Z=typeof m=="string",ft=(v||Z)&&m.length;return v?ft===f||ft===i:Z?ft===2*f||ft===2*i:m instanceof u}function V(m,v,Z=!0){if(H(m))throw new Error("first arg must be private key");if(!H(v))throw new Error("second arg must be public key");return u.fromHex(v).multiply(x(m)).toRawBytes(Z)}const S=n.bits2int||function(m){const v=w.bytesToNumberBE(m),Z=m.length*8-n.nBitLength;return Z>0?v>>BigInt(Z):v},k=n.bits2int_modN||function(m){return a(S(m))},R=w.dQ(n.nBitLength);function Et(m){if(typeof m!="bigint")throw new Error("bigint expected");if(!(Tt<=m&&m<R))throw new Error(`bigint expected < 2^${n.nBitLength}`);return w.tL(m,n.nByteLength)}function at(m,v,Z=F){if(["recovered","canonical"].some(Kt=>Kt in Z))throw new Error("sign() legacy options not supported");const{hash:ft,randomBytes:nt}=n;let{lowS:yt,prehash:At,extraEntropy:Ot}=Z;yt==null&&(yt=!0),m=(0,w.ql)("msgHash",m),At&&(m=(0,w.ql)("prehashed msgHash",ft(m)));const jt=k(m),Gt=x(v),Xt=[Et(Gt),Et(jt)];if(Ot!=null){const Kt=Ot===!0?nt(t.BYTES):Ot;Xt.push((0,w.ql)("extraEntropy",Kt))}const re=w.eV(...Xt),Mt=jt;function he(Kt){const Qt=S(Kt);if(!z(Qt))return;const xe=s(Qt),Jt=u.BASE.multiply(Qt).toAffine(),Ut=a(Jt.x);if(Ut===Tt)return;const Ft=a(xe*a(Mt+Ut*Gt));if(Ft===Tt)return;let Ee=(Jt.x===Ut?0:2)|Number(Jt.y&dt),Be=Ft;return yt&&I(Ft)&&(Be=l(Ft),Ee^=1),new p(Ut,Be,Ee)}return{seed:re,k2sig:he}}const F={lowS:n.lowS,prehash:!1},St={lowS:n.lowS,prehash:!1};function It(m,v,Z=F){const{seed:ft,k2sig:nt}=at(m,v,Z),yt=n;return w.n$(yt.hash.outputLen,yt.nByteLength,yt.hmac)(ft,nt)}u.BASE._setWindowSize(8);function Dt(m,v,Z,ft=St){var Jt;const nt=m;if(v=(0,w.ql)("msgHash",v),Z=(0,w.ql)("publicKey",Z),"strict"in ft)throw new Error("options.strict was renamed to lowS");const{lowS:yt,prehash:At}=ft;let Ot,jt;try{if(typeof nt=="string"||nt instanceof Uint8Array)try{Ot=p.fromDER(nt)}catch(Ut){if(!(Ut instanceof Ct.Err))throw Ut;Ot=p.fromCompact(nt)}else if(typeof nt=="object"&&typeof nt.r=="bigint"&&typeof nt.s=="bigint"){const{r:Ut,s:Ft}=nt;Ot=new p(Ut,Ft)}else throw new Error("PARSE");jt=u.fromHex(Z)}catch(Ut){if(Ut.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(yt&&Ot.hasHighS())return!1;At&&(v=n.hash(v));const{r:Gt,s:Xt}=Ot,re=k(v),Mt=s(Xt),he=a(re*Mt),Kt=a(Gt*Mt),Qt=(Jt=u.BASE.multiplyAndAddUnsafe(jt,he,Kt))==null?void 0:Jt.toAffine();return Qt?a(Qt.x)===Gt:!1}return{CURVE:n,getPublicKey:_,getSharedSecret:V,sign:It,verify:Dt,ProjectivePoint:u,Signature:p,utils:B}}function we(e,n){const t=e.ORDER;let r=Tt;for(let I=t-dt;I%Vt===Tt;I/=Vt)r+=dt;const f=r,i=Vt<<f-dt-dt,b=i*Vt,a=(t-dt)/b,s=(a-dt)/Vt,u=b-dt,x=i,E=e.pow(n,a),z=e.pow(n,(a+dt)/Vt);let J=(I,l)=>{let y=E,p=e.pow(l,u),B=e.sqr(p);B=e.mul(B,l);let _=e.mul(I,B);_=e.pow(_,s),_=e.mul(_,p),p=e.mul(_,l),B=e.mul(_,I);let H=e.mul(B,p);_=e.pow(H,x);let V=e.eql(_,e.ONE);p=e.mul(B,z),_=e.mul(H,y),B=e.cmov(p,B,V),H=e.cmov(_,H,V);for(let S=f;S>dt;S--){let k=S-Vt;k=Vt<<k-dt;let R=e.pow(H,k);const Et=e.eql(R,e.ONE);p=e.mul(B,y),y=e.mul(y,y),R=e.mul(H,y),B=e.cmov(p,B,Et),H=e.cmov(R,H,Et)}return{isValid:V,value:B}};if(e.ORDER%ie===ee){const I=(e.ORDER-ee)/ie,l=e.sqrt(e.neg(n));J=(y,p)=>{let B=e.sqr(p);const _=e.mul(y,p);B=e.mul(B,_);let H=e.pow(B,I);H=e.mul(H,_);const V=e.mul(H,l),S=e.mul(e.sqr(H),p),k=e.eql(S,y);let R=e.cmov(V,H,k);return{isValid:k,value:R}}}return J}function ve(e,n){if(mod.validateField(e),!e.isValid(n.A)||!e.isValid(n.B)||!e.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const t=we(e,n.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let f,i,b,a,s,u,x,E;f=e.sqr(r),f=e.mul(f,n.Z),i=e.sqr(f),i=e.add(i,f),b=e.add(i,e.ONE),b=e.mul(b,n.B),a=e.cmov(n.Z,e.neg(i),!e.eql(i,e.ZERO)),a=e.mul(a,n.A),i=e.sqr(b),u=e.sqr(a),s=e.mul(u,n.A),i=e.add(i,s),i=e.mul(i,b),u=e.mul(u,a),s=e.mul(u,n.B),i=e.add(i,s),x=e.mul(f,b);const{isValid:z,value:J}=t(i,u);E=e.mul(f,r),E=e.mul(E,J),x=e.cmov(x,b,z),E=e.cmov(E,J,z);const I=e.isOdd(r)===e.isOdd(E);return E=e.cmov(e.neg(E),E,I),x=e.div(x,a),{x,y:E}}}function ye(e){return{hash:e,hmac:(n,...t)=>kt(e,n,(0,xt.eV)(...t)),randomBytes:xt.O6}}function h(e,n){const t=r=>be({...e,...ye(r)});return Object.freeze({...t(n),create:t})}const o=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),d=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),U=BigInt(1),q=BigInt(2),st=(e,n)=>(e+n/q)/n;function $(e){const n=o,t=BigInt(3),r=BigInt(6),f=BigInt(11),i=BigInt(22),b=BigInt(23),a=BigInt(44),s=BigInt(88),u=e*e*e%n,x=u*u*e%n,E=P(x,t,n)*x%n,z=P(E,t,n)*x%n,J=P(z,q,n)*u%n,I=P(J,f,n)*J%n,l=P(I,i,n)*I%n,y=P(l,a,n)*l%n,p=P(y,s,n)*y%n,B=P(p,a,n)*l%n,_=P(B,t,n)*x%n,H=P(_,b,n)*I%n,V=P(H,r,n)*u%n,S=P(V,q,n);if(!ht.eql(ht.sqr(S),e))throw new Error("Cannot find square root");return S}const ht=W(o,void 0,void 0,{sqrt:$}),Pt=h({a:BigInt(0),b:BigInt(7),Fp:ht,n:d,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=d,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-U*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),f=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,b=BigInt("0x100000000000000000000000000000000"),a=st(i*e,n),s=st(-r*e,n);let u=C(e-a*t-s*f,n),x=C(-a*r-s*i,n);const E=u>b,z=x>b;if(E&&(u=n-u),z&&(x=n-x),u>b||x>b)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:E,k1:u,k2neg:z,k2:x}}}},rt.J),$t=BigInt(0),qt=e=>typeof e=="bigint"&&$t<e&&e<o,fe=e=>typeof e=="bigint"&&$t<e&&e<d,oe={};function Zt(e,...n){let t=oe[e];if(t===void 0){const r=sha256(Uint8Array.from(e,f=>f.charCodeAt(0)));t=concatBytes(r,r),oe[e]=t}return sha256(concatBytes(t,...n))}const pe=e=>e.toRawBytes(!0).slice(1),ae=e=>numberToBytesBE(e,32),ue=e=>mod(e,o),ne=e=>mod(e,d),le=Pt.ProjectivePoint,_e=(e,n,t)=>le.BASE.multiplyAndAddUnsafe(e,n,t);function de(e){let n=Pt.utils.normPrivateKeyToScalar(e),t=le.fromPrivateKey(n);return{scalar:t.hasEvenY()?n:ne(-n),bytes:pe(t)}}function Se(e){if(!qt(e))throw new Error("bad x: need 0 < x < p");const n=ue(e*e),t=ue(n*e+BigInt(7));let r=$(t);r%q!==$t&&(r=ue(-r));const f=new le(e,r,U);return f.assertValidity(),f}function me(...e){return ne(bytesToNumberBE(Zt("BIP0340/challenge",...e)))}function Ae(e){return de(e).bytes}function Oe(e,n,t=randomBytes(32)){const r=ensureBytes("message",e),{bytes:f,scalar:i}=de(n),b=ensureBytes("auxRand",t,32),a=ae(i^bytesToNumberBE(Zt("BIP0340/aux",b))),s=Zt("BIP0340/nonce",a,f,r),u=ne(bytesToNumberBE(s));if(u===$t)throw new Error("sign failed: k is zero");const{bytes:x,scalar:E}=de(u),z=me(x,f,r),J=new Uint8Array(64);if(J.set(x,0),J.set(ae(ne(E+z*i)),32),!Ie(J,r,f))throw new Error("sign: Invalid signature produced");return J}function Ie(e,n,t){const r=ensureBytes("signature",e,64),f=ensureBytes("message",n),i=ensureBytes("publicKey",t,32);try{const b=Se(bytesToNumberBE(i)),a=bytesToNumberBE(r.subarray(0,32));if(!qt(a))return!1;const s=bytesToNumberBE(r.subarray(32,64));if(!fe(s))return!1;const u=me(ae(a),pe(b),f),x=_e(b,s,ne(-u));return!(!x||!x.hasEvenY()||x.toAffine().x!==a)}catch{return!1}}const Le=null,ke=null,Te=null,Ne=null,Ue=null,He=null},60149:function(Wt,vt,ut){ut.d(vt,{Gg:function(){return ot},J8:function(){return O},Rx:function(){return rt},aI:function(){return j},vp:function(){return N}});function rt(L){if(!Number.isSafeInteger(L)||L<0)throw new Error(`Wrong positive integer: ${L}`)}function w(L){if(typeof L!="boolean")throw new Error(`Expected boolean, not ${L}`)}function j(L,...tt){if(!(L instanceof Uint8Array))throw new Error("Expected Uint8Array");if(tt.length>0&&!tt.includes(L.length))throw new Error(`Expected Uint8Array of length ${tt}, not of length=${L.length}`)}function N(L){if(typeof L!="function"||typeof L.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");rt(L.outputLen),rt(L.blockLen)}function ot(L,tt=!0){if(L.destroyed)throw new Error("Hash instance has been destroyed");if(tt&&L.finished)throw new Error("Hash#digest() has already been called")}function O(L,tt){j(L);const X=tt.outputLen;if(L.length<X)throw new Error(`digestInto() expects output buffer of length at least ${X}`)}const G={number:rt,bool:w,bytes:j,hash:N,exists:ot,output:O};var Y=null},35097:function(Wt,vt,ut){ut.d(vt,{N:function(){return N}});var rt=ut(60149),w=ut(82403);function j(ot,O,G,Y){if(typeof ot.setBigUint64=="function")return ot.setBigUint64(O,G,Y);const L=BigInt(32),tt=BigInt(4294967295),X=Number(G>>L&tt),C=Number(G&tt),it=Y?4:0,P=Y?0:4;ot.setUint32(O+it,X,Y),ot.setUint32(O+P,C,Y)}class N extends w.kb{constructor(O,G,Y,L){super(),this.blockLen=O,this.outputLen=G,this.padOffset=Y,this.isLE=L,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(O),this.view=(0,w.GL)(this.buffer)}update(O){(0,rt.Gg)(this);const{view:G,buffer:Y,blockLen:L}=this;O=(0,w.O0)(O);const tt=O.length;for(let X=0;X<tt;){const C=Math.min(L-this.pos,tt-X);if(C===L){const it=(0,w.GL)(O);for(;L<=tt-X;X+=L)this.process(it,X);continue}Y.set(O.subarray(X,X+C),this.pos),this.pos+=C,X+=C,this.pos===L&&(this.process(G,0),this.pos=0)}return this.length+=O.length,this.roundClean(),this}digestInto(O){(0,rt.Gg)(this),(0,rt.J8)(O,this),this.finished=!0;const{buffer:G,view:Y,blockLen:L,isLE:tt}=this;let{pos:X}=this;G[X++]=128,this.buffer.subarray(X).fill(0),this.padOffset>L-X&&(this.process(Y,0),X=0);for(let Q=X;Q<L;Q++)G[Q]=0;j(Y,L-8,BigInt(this.length*8),tt),this.process(Y,0);const C=(0,w.GL)(O),it=this.outputLen;if(it%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const P=it/4,et=this.get();if(P>et.length)throw new Error("_sha2: outputLen bigger than state");for(let Q=0;Q<P;Q++)C.setUint32(4*Q,et[Q],tt)}digest(){const{buffer:O,outputLen:G}=this;this.digestInto(O);const Y=O.slice(0,G);return this.destroy(),Y}_cloneInto(O){O||(O=new this.constructor),O.set(...this.get());const{blockLen:G,buffer:Y,length:L,finished:tt,destroyed:X,pos:C}=this;return O.length=L,O.pos=C,O.finished=tt,O.destroyed=X,L%G&&O.buffer.set(Y),O}}},23501:function(Wt,vt,ut){ut.d(vt,{J:function(){return tt}});var rt=ut(35097),w=ut(82403);const j=(C,it,P)=>C&it^~C&P,N=(C,it,P)=>C&it^C&P^it&P,ot=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),O=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),G=new Uint32Array(64);class Y extends rt.N{constructor(){super(64,32,8,!1),this.A=O[0]|0,this.B=O[1]|0,this.C=O[2]|0,this.D=O[3]|0,this.E=O[4]|0,this.F=O[5]|0,this.G=O[6]|0,this.H=O[7]|0}get(){const{A:it,B:P,C:et,D:Q,E:wt,F:pt,G:gt,H:mt}=this;return[it,P,et,Q,wt,pt,gt,mt]}set(it,P,et,Q,wt,pt,gt,mt){this.A=it|0,this.B=P|0,this.C=et|0,this.D=Q|0,this.E=wt|0,this.F=pt|0,this.G=gt|0,this.H=mt|0}process(it,P){for(let g=0;g<16;g++,P+=4)G[g]=it.getUint32(P,!1);for(let g=16;g<64;g++){const T=G[g-15],D=G[g-2],W=(0,w.np)(T,7)^(0,w.np)(T,18)^T>>>3,bt=(0,w.np)(D,17)^(0,w.np)(D,19)^D>>>10;G[g]=bt+G[g-7]+W+G[g-16]|0}let{A:et,B:Q,C:wt,D:pt,E:gt,F:mt,G:Nt,H:Lt}=this;for(let g=0;g<64;g++){const T=(0,w.np)(gt,6)^(0,w.np)(gt,11)^(0,w.np)(gt,25),D=Lt+T+j(gt,mt,Nt)+ot[g]+G[g]|0,bt=((0,w.np)(et,2)^(0,w.np)(et,13)^(0,w.np)(et,22))+N(et,Q,wt)|0;Lt=Nt,Nt=mt,mt=gt,gt=pt+D|0,pt=wt,wt=Q,Q=et,et=D+bt|0}et=et+this.A|0,Q=Q+this.B|0,wt=wt+this.C|0,pt=pt+this.D|0,gt=gt+this.E|0,mt=mt+this.F|0,Nt=Nt+this.G|0,Lt=Lt+this.H|0,this.set(et,Q,wt,pt,gt,mt,Nt,Lt)}roundClean(){G.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class L extends null{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const tt=(0,w.hE)(()=>new Y),X=null},27508:function(Wt,vt,ut){ut.d(vt,{fr:function(){return ce}});var rt=ut(60149);const w=BigInt(2**32-1),j=BigInt(32);function N(h,o=!1){return o?{h:Number(h&w),l:Number(h>>j&w)}:{h:Number(h>>j&w)|0,l:Number(h&w)|0}}function ot(h,o=!1){let d=new Uint32Array(h.length),U=new Uint32Array(h.length);for(let q=0;q<h.length;q++){const{h:st,l:$}=N(h[q],o);[d[q],U[q]]=[st,$]}return[d,U]}const O=(h,o)=>BigInt(h>>>0)<<j|BigInt(o>>>0),G=(h,o,d)=>h>>>d,Y=(h,o,d)=>h<<32-d|o>>>d,L=(h,o,d)=>h>>>d|o<<32-d,tt=(h,o,d)=>h<<32-d|o>>>d,X=(h,o,d)=>h<<64-d|o>>>d-32,C=(h,o,d)=>h>>>d-32|o<<64-d,it=(h,o)=>o,P=(h,o)=>h,et=(h,o,d)=>h<<d|o>>>32-d,Q=(h,o,d)=>o<<d|h>>>32-d,wt=(h,o,d)=>o<<d-32|h>>>64-d,pt=(h,o,d)=>h<<d-32|o>>>64-d;function gt(h,o,d,U){const q=(o>>>0)+(U>>>0);return{h:h+d+(q/2**32|0)|0,l:q|0}}const W={fromBig:N,split:ot,toBig:O,shrSH:G,shrSL:Y,rotrSH:L,rotrSL:tt,rotrBH:X,rotrBL:C,rotr32H:it,rotr32L:P,rotlSH:et,rotlSL:Q,rotlBH:wt,rotlBL:pt,add:gt,add3L:(h,o,d)=>(h>>>0)+(o>>>0)+(d>>>0),add3H:(h,o,d,U)=>o+d+U+(h/2**32|0)|0,add4L:(h,o,d,U)=>(h>>>0)+(o>>>0)+(d>>>0)+(U>>>0),add4H:(h,o,d,U,q)=>o+d+U+q+(h/2**32|0)|0,add5H:(h,o,d,U,q,st)=>o+d+U+q+st+(h/2**32|0)|0,add5L:(h,o,d,U,q)=>(h>>>0)+(o>>>0)+(d>>>0)+(U>>>0)+(q>>>0)};var bt=null,c=ut(82403);const[A,M,K]=[[],[],[]],lt=BigInt(0),ct=BigInt(1),xt=BigInt(2),_t=BigInt(7),kt=BigInt(256),te=BigInt(113);for(let h=0,o=ct,d=1,U=0;h<24;h++){[d,U]=[U,(2*d+3*U)%5],A.push(2*(5*U+d)),M.push((h+1)*(h+2)/2%64);let q=lt;for(let st=0;st<7;st++)o=(o<<ct^(o>>_t)*te)%kt,o&xt&&(q^=ct<<(ct<<BigInt(st))-ct);K.push(q)}const[zt,Bt]=ot(K,!0),Ht=(h,o,d)=>d>32?wt(h,o,d):et(h,o,d),Rt=(h,o,d)=>d>32?pt(h,o,d):Q(h,o,d);function se(h,o=24){const d=new Uint32Array(10);for(let U=24-o;U<24;U++){for(let $=0;$<10;$++)d[$]=h[$]^h[$+10]^h[$+20]^h[$+30]^h[$+40];for(let $=0;$<10;$+=2){const ht=($+8)%10,Pt=($+2)%10,$t=d[Pt],qt=d[Pt+1],fe=Ht($t,qt,1)^d[ht],oe=Rt($t,qt,1)^d[ht+1];for(let Zt=0;Zt<50;Zt+=10)h[$+Zt]^=fe,h[$+Zt+1]^=oe}let q=h[2],st=h[3];for(let $=0;$<24;$++){const ht=M[$],Pt=Ht(q,st,ht),$t=Rt(q,st,ht),qt=A[$];q=h[qt],st=h[qt+1],h[qt]=Pt,h[qt+1]=$t}for(let $=0;$<50;$+=10){for(let ht=0;ht<10;ht++)d[ht]=h[$+ht];for(let ht=0;ht<10;ht++)h[$+ht]^=~d[(ht+2)%10]&d[(ht+4)%10]}h[0]^=zt[U],h[1]^=Bt[U]}d.fill(0)}class Yt extends c.kb{constructor(o,d,U,q=!1,st=24){if(super(),this.blockLen=o,this.suffix=d,this.outputLen=U,this.enableXOF=q,this.rounds=st,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,rt.Rx)(U),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,c.Jq)(this.state)}keccak(){se(this.state32,this.rounds),this.posOut=0,this.pos=0}update(o){(0,rt.Gg)(this);const{blockLen:d,state:U}=this;o=(0,c.O0)(o);const q=o.length;for(let st=0;st<q;){const $=Math.min(d-this.pos,q-st);for(let ht=0;ht<$;ht++)U[this.pos++]^=o[st++];this.pos===d&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:o,suffix:d,pos:U,blockLen:q}=this;o[U]^=d,d&128&&U===q-1&&this.keccak(),o[q-1]^=128,this.keccak()}writeInto(o){(0,rt.Gg)(this,!1),(0,rt.aI)(o),this.finish();const d=this.state,{blockLen:U}=this;for(let q=0,st=o.length;q<st;){this.posOut>=U&&this.keccak();const $=Math.min(U-this.posOut,st-q);o.set(d.subarray(this.posOut,this.posOut+$),q),this.posOut+=$,q+=$}return o}xofInto(o){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(o)}xof(o){return(0,rt.Rx)(o),this.xofInto(new Uint8Array(o))}digestInto(o){if((0,rt.J8)(o,this),this.finished)throw new Error("digest() was already called");return this.writeInto(o),this.destroy(),o}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(o){const{blockLen:d,suffix:U,outputLen:q,rounds:st,enableXOF:$}=this;return o||(o=new Yt(d,U,q,$,st)),o.state32.set(this.state32),o.pos=this.pos,o.posOut=this.posOut,o.finished=this.finished,o.rounds=st,o.suffix=U,o.outputLen=q,o.enableXOF=$,o.destroyed=this.destroyed,o}}const Ct=(h,o,d)=>(0,c.hE)(()=>new Yt(o,h,d)),Tt=null,dt=null,Vt=null,ee=null,ie=null,ce=Ct(1,136,256/8),ge=null,be=null,we=(h,o,d)=>wrapXOFConstructorWithOpts((U={})=>new Yt(o,h,U.dkLen===void 0?d:U.dkLen,!0)),ve=null,ye=null},82403:function(Wt,vt,ut){ut.d(vt,{kb:function(){return Q},eV:function(){return et},GL:function(){return ot},O6:function(){return Lt},np:function(){return O},O0:function(){return P},Jq:function(){return N},hE:function(){return gt}});const rt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;const w=g=>g instanceof Uint8Array,j=g=>new Uint8Array(g.buffer,g.byteOffset,g.byteLength),N=g=>new Uint32Array(g.buffer,g.byteOffset,Math.floor(g.byteLength/4)),ot=g=>new DataView(g.buffer,g.byteOffset,g.byteLength),O=(g,T)=>g<<32-T|g>>>T;if(!(new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68))throw new Error("Non little-endian hardware is not supported");const Y=Array.from({length:256},(g,T)=>T.toString(16).padStart(2,"0"));function L(g){if(!w(g))throw new Error("Uint8Array expected");let T="";for(let D=0;D<g.length;D++)T+=Y[g[D]];return T}function tt(g){if(typeof g!="string")throw new Error("hex string expected, got "+typeof g);const T=g.length;if(T%2)throw new Error("padded hex string expected, got unpadded hex of length "+T);const D=new Uint8Array(T/2);for(let W=0;W<D.length;W++){const bt=W*2,c=g.slice(bt,bt+2),A=Number.parseInt(c,16);if(Number.isNaN(A)||A<0)throw new Error("Invalid byte sequence");D[W]=A}return D}const X=async()=>{};async function C(g,T,D){let W=Date.now();for(let bt=0;bt<g;bt++){D(bt);const c=Date.now()-W;c>=0&&c<T||(await X(),W+=c)}}function it(g){if(typeof g!="string")throw new Error(`utf8ToBytes expected string, got ${typeof g}`);return new Uint8Array(new TextEncoder().encode(g))}function P(g){if(typeof g=="string"&&(g=it(g)),!w(g))throw new Error(`expected Uint8Array, got ${typeof g}`);return g}function et(...g){const T=new Uint8Array(g.reduce((W,bt)=>W+bt.length,0));let D=0;return g.forEach(W=>{if(!w(W))throw new Error("Uint8Array expected");T.set(W,D),D+=W.length}),T}class Q{clone(){return this._cloneInto()}}const wt={}.toString;function pt(g,T){if(T!==void 0&&wt.call(T)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(g,T)}function gt(g){const T=W=>g().update(P(W)).digest(),D=g();return T.outputLen=D.outputLen,T.blockLen=D.blockLen,T.create=()=>g(),T}function mt(g){const T=(W,bt)=>g(bt).update(P(W)).digest(),D=g({});return T.outputLen=D.outputLen,T.blockLen=D.blockLen,T.create=W=>g(W),T}function Nt(g){const T=(W,bt)=>g(bt).update(P(W)).digest(),D=g({});return T.outputLen=D.outputLen,T.blockLen=D.blockLen,T.create=W=>g(W),T}function Lt(g=32){if(rt&&typeof rt.getRandomValues=="function")return rt.getRandomValues(new Uint8Array(g));throw new Error("crypto.getRandomValues must be defined")}}}]);
